\newcommand{\doctitle}{Bachelor Project in Computer Science}
\newcommand{\docauthor}{Danny Nygård Hansen}

\documentclass[a4paper, 11pt, article, danish, oneside]{memoir}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[UKenglish]{babel}
\usepackage[autostyle]{csquotes}

\usepackage[final]{microtype}
\frenchspacing
\raggedbottom

\usepackage{mathtools}
\usepackage{amssymb}
\usepackage[largesmallcaps]{kpfonts}
\linespread{1.06}
\DeclareMathAlphabet\mathfrak{U}{euf}{m}{n}
\SetMathAlphabet\mathfrak{bold}{U}{euf}{b}{n}
\usepackage{inconsolata}

\usepackage{hyperref}
\hypersetup{%
	pdftitle=\doctitle,
	pdfauthor={\docauthor},
    hidelinks,
}

\usepackage{theorems-changedot}
\usepackage{theorems-references}

\usepackage{enumitem}
\setenumerate[0]{label=\normalfont(\arabic*)}
\setlist{
	listparindent=\parindent,
	parsep=0pt,
}
\usepackage{array}

\title{\doctitle}
\author{\docauthor}

\newcommand{\overbar}[3]{\mkern #1mu\overline{\mkern-#1mu#3\mkern-#2mu}\mkern #2mu}
\newcommand{\naturals}{\mathbb{N}}
\newcommand{\ints}{\mathbb{Z}}
\newcommand{\rationals}{\mathbb{Q}}
\newcommand{\reals}{\mathbb{R}}
\newcommand{\extreals}{\overbar{1.5}{1.5}{\reals}}
\newcommand{\complex}{\mathbb{C}}


\usepackage{pgffor}

\newcommand{\rvar}[1]{\mathsf{#1}}

\foreach \x in {A,...,Z}{%
    \expandafter\xdef\csname cal\x\endcsname{\noexpand\mathcal{\x}}
    \expandafter\xdef\csname frak\x\endcsname{\noexpand\mathfrak{\x}}
    \expandafter\xdef\csname rand\x\endcsname{\noexpand\rvar{\x}}
}


\usepackage{etoolbox}
\newcommand{\blank}{\mathrel{\;\cdot\;}}
\newcommand{\blankifempty}[1]{\ifstrempty{#1}{\blank}{#1}}
\DeclarePairedDelimiter{\auxdelimlvert}{\lvert}{\rvert}
\DeclarePairedDelimiter{\auxdelimlVert}{\lVert}{\rVert}
\DeclarePairedDelimiterX{\auxdelimanglescomma}[2]{\langle}{\rangle}{#1,#2}
\newcommand{\abs}[1]{\auxdelimlvert{\blankifempty{#1}}}
\newcommand{\norm}[1]{\auxdelimlVert{\blankifempty{#1}}}
\newcommand{\inner}[2]{\auxdelimanglescomma{\blankifempty{#1}}{\blankifempty{#2}}}


\DeclarePairedDelimiter{\auxdelimparen}{(}{)}
\DeclarePairedDelimiterX{\auxdelimparencomma}[2]{(}{)}{#1,#2}
\DeclarePairedDelimiter{\auxdelimbracket}{[}{]}
\DeclarePairedDelimiterX{\auxdelimbracketcomma}[2]{[}{]}{#1,#2}
\newcommand{\powerset}[2][]{\calP\auxdelimparen[#1]{#2}}
\newcommand{\powersetcard}[3][]{\calP_{#2}\auxdelimparen[#1]{#3}}
\newcommand{\powersetfin}[2][]{\powersetcard[#1]{\omega}{#2}}
\newcommand{\borel}[2][]{\calB\auxdelimparen[#1]{#2}}
\newcommand{\meas}[2][]{\calM\auxdelimparen[#1]{#2}}
\newcommand{\measC}[2][]{\calM_\complex\auxdelimparen[#1]{#2}}
\newcommand{\measpos}[2][]{\meas[#1]{#2}^+}
\newcommand{\measbound}[2][]{\calM_b\auxdelimparen[#1]{#2}}
\newcommand{\measboundpos}[2][]{\measbound[#1]{#2}^+}


\newcommand{\extmeas}[2][]{\overbar{4.5}{0.5}{\calM}\auxdelimparen[#1]{#2}}
\newcommand{\extmeaspos}[2][]{\extmeas[#1]{#2}^+}
\newcommand{\simplemeas}[2][]{\calS\!\calM\auxdelimparen[#1]{#2}}
\newcommand{\simplemeaspos}[2][]{\simplemeas[#1]{#2}^+}
\newcommand{\sigmaalg}[2][]{\sigma\auxdelimparen[#1]{#2}}
\newcommand{\deltasys}[2][]{\delta\auxdelimparen[#1]{#2}}

\newcommand{\expval}[2][]{\mathbb{E}\auxdelimbracket[#1]{#2}}
\newcommand{\var}[2][]{\operatorname{Var}\auxdelimbracket[#1]{#2}}
\newcommand{\cov}[3][]{\operatorname{Cov}\auxdelimbracketcomma[#1]{#2}{#3}}


\renewcommand{\Re}{\operatorname{Re}}
\renewcommand{\Im}{\operatorname{Im}}
\newcommand{\conj}[1]{\overline{#1}}
\newcommand{\dif}{\mathop{}\!\mathrm{d}}
\DeclareMathOperator{\id}{id}
\newcommand{\indicator}[1]{\mathbf{1}_{#1}}

% Lattice operations
\newcommand{\meet}{\land}
\newcommand{\join}{\lor}

\DeclareMathOperator*{\smallbigvee}{\textstyle\bigvee}
\DeclareMathOperator*{\bigjoin}{\mathchoice
    {\smallbigvee}%
    {\bigvee}%
    {\bigvee}%
    {\bigvee}%
}
\DeclareMathOperator*{\smallbigwedge}{\textstyle\bigwedge}
\DeclareMathOperator*{\bigmeet}{\mathchoice
    {\smallbigwedge}%
    {\bigwedge}%
    {\bigwedge}%
    {\bigwedge}%
}



\newcommand*\union\cup
\newcommand*\intersect\cap

\DeclareMathOperator*{\smallbigcup}{\textstyle\bigcup}
\DeclareMathOperator*{\bigunion}{\mathchoice
    {\smallbigcup}%
    {\bigcup}%
    {\bigcup}%
    {\bigcup}%
}
\DeclareMathOperator*{\smallbigcap}{\textstyle\bigcap}
\DeclareMathOperator*{\bigintersect}{\mathchoice
    {\smallbigcap}%
    {\bigcap}%
    {\bigcap}%
    {\bigcap}%
}


\DeclarePairedDelimiterX{\set}[2]{\lbrace}{\rbrace}{#1\;\delimsize\vert\;#2}

\newcommand{\defeq}{\coloneqq}
\renewcommand{\phi}{\varphi}
\newcommand{\iu}{\mathrm{i}\mkern1mu}
\DeclareMathOperator{\e}{\mathrm{e}}

\newcommand{\ball}[3][]{%
    \ifstrempty{#1}%
        {%
            b\auxdelimparencomma{#2}{#3}%
        }{%
            b_{#1}\auxdelimparencomma{#2}{#3}%
        }%
}

\newcommand{\converges}[1]{\xrightarrow[#1]{}}
\DeclareMathOperator{\supp}{supp}
\let\oldvec\vec
\renewcommand{\vec}[1]{\underline{#1}}
\newcommand{\Tr}[1][]{%
    \ifstrempty{#1}%
        {%
            \operatorname{Tr}%
        }{%
            \operatorname{Tr}_{#1}%
        }%
}


\usepackage{listofitems}
\setsepchar{,}

\makeatletter
\newcommand{\mat@dims}[1]{%
    \readlist*\@dims{#1}%
    \ifnum \@dimslen=1
        \def\@dimsout{\@dims[1]}%
    \else
        \def\@dimsout{\@dims[1], \@dims[2]}%
    \fi
    \@dimsout
}


\newcommand{\matgroup}[3]{\mathrm{#1}_{#2}(#3)}
\newcommand{\matGL}[2]{\matgroup{GL}{#1}{#2}}
\newcommand{\trans}{^{\top}}
\newcommand{\mat}[2]{M_{\mat@dims{#1}}(#2)}

\makeatother

\DeclareMathOperator{\Span}{span}
\DeclareMathOperator{\clSpan}{\overbar{0.5}{1.5}{span}}

\newcommand\inv{^{\langle-1\rangle}}
\newcommand{\preim}[2][]{^{-1}\auxdelimparen[#1]{#2}}

\newcommand{\dsupp}[2][]{\mathrm{Sp}_d\auxdelimparen[#1]{#2}}

\usepackage{xcolor}
\usepackage{biolinum}
\usepackage{mathpartir}


\begin{document}

\maketitle

% \newcommand{\hastype}[4]{#1 \mid #2 \vdash #3 : #4}
\newcommand{\hastype}[5]{%
    \ifstrempty{#1}%
        {%
            \ifstrempty{#2}%
            {%
                #3 \vdash #4 : #5%
            }{%
                #2 \mid #3 \vdash #4 : #5%
            }%
        }{%
            \ifstrempty{#2}%
            {%
                #1 \mid \emptyset \mid #3 \vdash #4 : #5%
            }{%
                #1 \mid #2 \mid #3 \vdash #4 : #5%
            }%
        }%
}

\newcommand{\stotype}[4]{%
    \ifstrempty{#1}%
        {%
            \ifstrempty{#2}%
            {%
                #3 \vdash #4%
            }{%
                #2 \mid #3 \vdash #4%
            }%
        }{%
            \ifstrempty{#2}%
            {%
                #1 \mid \emptyset \mid #3 \vdash #4%
            }{%
                #1 \mid #2 \mid #3 \vdash #4%
            }%
        }%
}


\newcommand{\step}{\to}
\newcommand{\headstep}{\to_h}
\newcommand{\purestep}{\to_p}
\newcommand{\infrule}[1]{{\normalfont\textsc{#1}}}
\newcommand{\hole}{-}
\newcommand{\unitval}{()}
\newcommand{\STLC}{\lambda_{\rightarrow}}

% \newcommand{\keyword}[1]{\textbf{\textit{#1}}}
\newcommand{\pto}{\rightharpoonup}
\newcommand{\dom}{\operatorname{dom}}
\newcommand{\ran}{\operatorname{ran}}

\newcommand{\textlang}[1]{\textsf{#1}}
\newcommand{\langkw}[1]{\textlang{\color{objlangcolor} #1}}
\newcommand{\Fst}{\operatorname{\langkw{fst}}}
\newcommand{\Snd}{\operatorname{\langkw{snd}}}
\renewcommand{\prod}{\times}

\newcommand{\objlang}[1]{{\normalfont\textsf{\textcolor{objlangcolor}{#1}}}}
\definecolor{objlangcolor}{HTML}{A91616}

\newcommand{\objOp}[1]{\operatorname{\objlang{#1}}}
\newcommand{\objDelim}[1]{\objlang{(}#1\objlang{)}}

\newcommand{\objFst}[1]{\objOp{fst}#1}
\newcommand{\objSnd}[1]{\objOp{snd}#1}
\newcommand{\objInl}[1]{\objOp{inj}_{\objlang{1}}#1}
\newcommand{\objInr}[1]{\objOp{inj}_{\objlang{2}}#1}

\newcommand{\objPair}[2]{\objDelim{#1\mathpunct{\objlang{,}}#2}}
\newcommand{\objUnit}{\objlang{()}}
\newcommand{\objRec}[3]{\objOp{rec}#1\objDelim{#2} \mathrel{\textcolor{objlangcolor}{\ensuremath{\coloneqq}}} #3}
\newcommand{\objApp}[2]{#1\,#2}
\newcommand{\objAss}[2]{#1 \mathrel{\textcolor{objlangcolor}{\ensuremath{\coloneqq}}} #2}

\newcommand{\objMatch}[4]{\objlang{match} \;#1\, \objlang{with}\: \objInl{#2} \mathbin{\textcolor{objlangcolor}{\Rightarrow}} #3 \mathbin{\textcolor{objlangcolor}{\mid}} \objInr{#2} \mathbin{\textcolor{objlangcolor}{\Rightarrow}} #4 \,\objlang{end}} % TODO xcolor now has \mathcolor? Have to update TeXlive?

\newcommand{\objForall}[2]{\objApp{\textcolor{objlangcolor}{\Lambda}}{#2}}

\newcommand{\setVar}{\mathit{Var}}
\newcommand{\setTVar}{\mathit{TVar}}
\newcommand{\setLoc}{\mathit{Loc}}
\newcommand{\setSto}{\mathit{Sto}}
\newcommand{\setExp}{\mathit{Exp}}
\newcommand{\setVal}{\mathit{Val}}
\newcommand{\setType}{\mathit{Type}}
\newcommand{\setECtx}{\mathit{ECtx}}
\newcommand{\setTAnn}{\mathit{TAnn}}
\newcommand{\typeUnit}{\textsf{Unit}}
\newcommand{\freevar}[1]{\mathit{FV}(#1)}
\newcommand{\freeTvar}[1]{\mathit{FTV}(#1)}
% \newcommand{\powersetcard}[2]{\calP_\omega(#1)}
\newcommand{\pmaps}[3][]{#2 \pto_{#1} #3}
\newcommand{\typeForall}[2]{\forall #1. #2}
\newcommand{\typeExists}[2]{\exists #1. #2}
\newcommand{\typeRef}[1]{\textsf{ref(}#1\textsf{)}}
\newcommand{\objTapp}[2]{\objApp{#1}{\textcolor{objlangcolor}{\_}}}
\newcommand{\objPack}[1]{\objOp{pack}#1}
\newcommand{\objUnpack}[3]{\objlang{unpack}\,#1\,\objlang{as}\,#2\,\objlang{in}\,#3}
\newcommand{\objRef}[1]{\objOp{ref}#1}
\newcommand{\objLoad}[1]{\objOp{!}#1}

If $X$ and $A$ are sets, then we write $A \subseteq_\kappa X$ if $A$ is a subset of $X$ with cardinality strictly less than $\kappa$. We denote the power set of $X$ by $\powerset{X}$, and we furthermore write $\powersetcard{\kappa}{X}$ for the collection of sets $A$ with $A \subseteq_\kappa X$. We do not distinguish between the ordinal $\omega$ and the cardinal $\aleph_0$, so we write $A \subseteq_\omega X$ if $A$ is a finite subset of $X$, and $\powersetfin{X}$ similarly denotes the set of finite subsets of $X$. If $Y$ is another set, then we denote the set of partial maps from $X$ to $Y$ by $\pmaps{X}{Y}$. For $f \in \pmaps{X}{Y}$ we let $\dom f$ and $\ran f$ denote the domain and range of $f$, respectively. We also write $\pmaps[\kappa]{X}{Y}$ for the subset of $\pmaps{X}{Y}$ of partial maps whose domain has cardinality strictly less than $\kappa$, and elements in $\pmaps[\omega]{X}{Y}$ will be called \keyword{finite partial maps}. For $x_0 \in X$ and $y_0 \in Y$ we denote by $f[x_0 \mapsto y_0]$ the partial map given by
%
\begin{equation*}
    f[x_0 \mapsto y_0](x) =
    \begin{cases}
        y_0, & x = x_0, \\
        f(x), & x \in \dom f \setminus \{x_0\}.
    \end{cases}
\end{equation*}
%
Notice in particular that $\dom f[x_0 \mapsto y_0] = \dom f \union \{x_0\}$, so that if $f \in \pmaps[\omega]{X}{Y}$, then also $f[x_0 \mapsto y_0] \in \pmaps[\omega]{X}{Y}$.

If $\Xi \subseteq_\omega \setTVar$, $\Gamma$ is a type context and $\Sigma$ is a store typing, then we say that a store $\sigma$ is \keyword{well-typed} with respect to $\Xi$, $\Gamma$ and $\Sigma$ if $\dom \sigma = \dom \Sigma$ and $\hastype{\Xi}{\Gamma}{\Sigma}{\sigma(l)}{\Sigma(l)}$ for all $l \in \dom \sigma$. In this case we write $\stotype{\Xi}{\Gamma}{\Sigma}{\sigma}$, and if $\Xi$ and $\Gamma$ are both empty we simply write $\stotype{}{}{\Sigma}{\sigma}$.

\begin{theorem}[Progress]
    Let $e$ be an expression and $\tau$ a type of $\STLC$.\footnote{TODO note different versions of STLC with and without products/sums etc., see wikipedia} If $\hastype{}{}{\Sigma}{e}{\tau}$, then either $e$ is a value or else, for any store $\sigma$ with $\stotype{}{}{\Sigma}{\sigma}$, there exists an expression $e'$ and a store $\sigma'$ such that $(\sigma,e) \step (\sigma',e')$.
\end{theorem}

\begin{proof}
The proof is by induction on the typing relation $\hastype{\Xi}{\Gamma}{\Sigma}{e}{\tau}$, but the claim to be proved is augmented by \textquote{or either $\Gamma$ or $\Xi$ is non-empty}.\footnote{This ensures that we can perform the induction on the entire $4$-ary relation, which is important since this relation is the one that is defined by the inference rules, \emph{not} the corresponding binary relation obtained by restricting the ternary relation to the subset where $\Xi$ and $\Gamma$ are empty.} Notice that the induction step for each inference rule is trivial if $\Xi$ or $\Gamma$ is non-empty, so we need only prove each case when $\Xi$ and $\Gamma$ are empty. [TODO mention store]
%
\begin{proofsec}
    \item[\infrule{T-unit}]
    Since $\objUnit$ is a value, this follows.

    \item[\infrule{T-var}]
    Since we may assume that $\Gamma$ is empty, this implication is vacuously true.\footnote{In the formalism of TODO ref \infrule{T-var} would not be an inference rule, it would instead be an axiom requiring the relation to include all quadruples $(\Xi, \Gamma, e, \tau)$ such that $(e : \tau) \in \Gamma$ and all type variables in $\tau$ occur in $\Xi$. This is of course also vacuously true when $\Gamma$ is empty.}

    \item[\infrule{T-pair}]
    Assume that the claim holds for $\hastype{}{}{\Sigma}{e_1}{\tau_1}$ and $\hastype{}{}{\Sigma}{e_2}{\tau_2}$. If both $e_1$ and $e_2$ are values, then $\objPair{e_1}{e_2}$ is also a value, so assume that only $e_1 = v_1$ is a value and that $e_2 \step e_2'$. Since the only rule that generates instances of the one-step relation $\to$ is \infrule{head-step-step}, it follows that $e_2$ is on the form $K[d_2]$ and $e_2'$ is on the form $K[d_2']$, where $K$ is an evaluation context and $d_2$ and $d_2'$ are subexpressions of $e_2$ and $e_2'$ respectively such that $d_2 \headstep d_2'$. Letting $K' = \objPair{v_1}{K}$ it follows that $\objPair{v_1}{e_2} = K'[d_2]$ and $\objPair{v_1}{e_2'} = K'[d_2']$, and so
    %
    \begin{equation*}
        \objPair{v_1}{e_2}
            = K'[d_2]
            \step K'[d_2']
            = \objPair{v_1}{e_2'}
    \end{equation*}
    %
    by \infrule{head-step-step}. If instead $e_1$ is not a value, then the same argument (using the evaluation context $\objPair{K}{e_2}$) yields the same result.

    \item[\infrule{T-fst}]
    Assume that the claim holds for $\hastype{}{}{\Sigma}{e}{\tau_1 \prod \tau_2}$. If $e$ is a value, then it is on the form $\objPair{v_1}{v_2}$ [TODO canonical forms], where $v_1$ and $v_2$ are values. Hence $\objFst{e} = \objFst{\objPair{v_1}{v_2}}$, and this reduces via a head-step to $v_1$. Choosing the evaluation context $K = \hole$, \infrule{head-step-step} implies that $\objFst{\objPair{v_1}{v_2}} \step v_1$. If instead $e$ is not a value, then by induction there is some $e'$ such that $e \to e'$. Hence there are subexpressions $d$ and $d'$ and an evaluation context $K$ such that $e = K[d]$, $e' = K[d']$ and $d \headstep d'$. Letting $K' = \objFst{K}$ we have
    %
    \begin{equation*}
        \objFst{e}
            = K'[d]
            \step K'[d']
            = \objFst{e'},
    \end{equation*}
    %
    as desired.

    \item[\infrule{T-snd}]
    Similar to \infrule{T-fst}.

    \item[\infrule{T-inj1}]
    Assume that the claim holds for $\hastype{}{}{\Sigma}{e}{\tau_1}$. If $e$ is a value $v$, then so is $\objInl{v}$. If instead $e \step e'$, then as before $e = K[d]$, $e' = K[d']$ and $d \headstep d'$. Letting $K' = \objInl{K}$ we get $\objInl{e} = K'[d]$ and $\objInl{e'} = K'[d']$, so $\objInl{e} \step \objInl{e'}$.

    \item[\infrule{T-inj2}]
    Similar to \infrule{T-inj1}.

    \item[\infrule{T-match}]
    Assume that the claim holds for $\hastype{}{}{\Sigma}{e_1}{\tau_1 + \tau_2}$. If $e_1$ is a value, then by [TODO canonical forms] it must be on the form $\objInl{v}$ or $\objInr{v}$ for a value $v$. Hence the expression $\objMatch{e_1}{x}{e_2}{e_3}$ can reduce via a head step by either \infrule{E-match-inj1} or \infrule{E-match-inj2}, so it reduces by \infrule{head-step-step} (using the evaluation context $K = \hole$). If instead $e_1 \step e_1'$, then by the same argument as in previous cases with $K' = \objMatch{K}{x}{e_2}{e_3}$, it follows that $\objMatch{e_1}{x}{e_2}{e_3}$ reduces.

    \item[\infrule{T-rec}]
    This is obvious since $\objRec{f}{x}{e}$ is a value.

    \item[\infrule{T-app}]
    Assume that the claim holds for $\hastype{}{}{\Sigma}{e_1}{\tau_1 \to \tau_2}$ and $\hastype{}{}{\Sigma}{e_2}{\tau_1}$. If $e_1$ is a value, then by [TODO canonical forms] it must be on the form $\objRec{f}{x}{e}$. If also $e_2$ is a value, then the claim follows by \infrule{E-rec-app}. If $e_1 = v$ is a value but $e_2$ is not, then $e_2 \to e_2'$. The same argument as in previous cases with $K' = \objApp{v}{K}$ shows that $\objApp{v}{e_2}$ reduces. Finally, if $e_1$ is not a value, then $e_1 \to e_1'$, and choosing $K' = \objApp{K}{e_2}$ proves the claim.

    \item[\infrule{T-Tlam}]
    This is obvious since $\objForall{X}{e}$ is a value.

    \item[\infrule{T-Tapp}]
    Assume that the claim holds for $\hastype{}{}{\Sigma}{e}{\typeForall{X}{\tau}}$. If $e$ is a value, then by [TODO canonical forms] it must be on the form $\objForall{X}{e'}$, so the claim follows from \infrule{E-tapp-tlam} (via \infrule{head-step-step} using the evaluation context $K = \hole$). If $e$ is not a value, then $e \to e'$ for some expression $e'$ by induction. These expressions then have subexpressions $d$ and $d'$ respectively such that $d \headstep d'$, and such that $e = K[d]$ and $e' = K[d']$ for some evaluation context $K$. Letting $K' = \objTapp{K}{\tau'}$ we thus have $\objTapp{e}{\tau'} = K'[d]$ and $\objTapp{e'}{\tau'} = K'[d']$, proving the claim.

    \item[\infrule{T-pack}]
    Assume that the claim holds for $\hastype{}{}{\Sigma}{e}{\tau[\tau'/X]}$. If $e$ is a value, then so is $\objPack{e}$. Otherwise $e \step e'$ for some expression $e'$. The same argument as before using the evaluation context $\objPack{K}$ for an appropriate $K$ yields the claim.

    \item[\infrule{T-unpack}]
    Assume that the claim holds for $\hastype{}{}{\Sigma}{e_1}{\typeExists{X}{\tau}}$. If $e_1$ is a value, then it must be on the form $\objPack{v}$ [TODO canonical forms], so an application of \infrule{E-unpack-pack} yields the claim. Otherwise $e \step e'$ for some $e'$, and we use the evaluation context $\objUnpack{K}{x}{e_2}$ for an appropriate $K$.

    \item[\infrule{T-fold}]
    TODO

    \item[\infrule{T-unfold}]
    TODO

    \item[\infrule{T-loc}]
    Locations are values, so this is obvious.

    \item[\infrule{T-alloc}]
    Assume that the claim holds for $\hastype{}{}{\Sigma}{e}{\tau}$. If $e$ is a value, then the claim follows by applying \infrule{E-alloc}, noting that there always exists a location $l \not\in \dom \sigma$. Otherwise given an appropriate [TODO well-typed] store $\sigma$ there is an expression $e'$ and a store $\sigma'$ such that $(\sigma,e) \step (\sigma',e')$. But then there is some evaluation context $K$ and subexpressions $d$ and $d'$ of $e$ and $e'$ respectively, such that $e = K[d]$, $e' = K[d']$ and $(\sigma,d) \headstep (\sigma',d')$. Letting $K' = \objRef{K}$ we have $\objRef{e} = K'[d]$ and $\objRef{e'} = K'[d']$, so \infrule{head-step-step} implies that $(\sigma,\objRef{e}) \step (\sigma',\objRef{e'})$.

    \item[\infrule{T-store}]
    Assume that the claim holds for $\hastype{}{}{\Sigma}{e_1}{\typeRef{\tau}}$ and $\hastype{}{}{\Sigma}{e_2}{\tau}$, and let $\sigma$ be a store with $\stotype{}{}{\Sigma}{\sigma}$. If $e_1$ is a value, then by [TODO canonical forms] it is a location $l$, and by [TODO lemma] we have $l \in \dom \Sigma = \dom \sigma$. If $e_2$ is also a value, then the claim follows from \infrule{E-store}. If $e_1 = l$ is a value but $e_2$ is not, then there is some $e_2'$ and $\sigma'$ such that $(\sigma,e_2) \step (\sigma',e_2')$. Again writing $e_2 = K[d_2]$ and $e_2' = K[d_2']$ with $(\sigma,d) \headstep (\sigma',d')$, we use the evaluation context $\objAss{l}{K}$. Finally, if $e_1$ is not a value, then the same argument using instead $\objAss{K}{e_2}$ yields the claim.

    \item[\infrule{T-load}]
    Assume that the claim holds for $\hastype{}{}{\Sigma}{e}{\typeRef{\tau}}$, and let $\sigma$ be a store with $\stotype{}{}{\Sigma}{\sigma}$. If $e$ is a value, then as before it is a location $l$, and $l \in \dom \sigma$. It then follows from \infrule{E-load} that $(\sigma, \objLoad{l}) \headstep (\sigma,v)$, where $v = \sigma(l)$. If instead $(\sigma,e) \step (\sigma',e')$ for an expression $e'$ and a store $\sigma'$, then we simply use the evaluation context $\objLoad{K}$ for an appropriate $K$.
\end{proofsec}
\end{proof}

% OLD
% Progress: Let $e$ be an expression and $\tau$ a type. If $\hastype{}{}[\Sigma}{e}{\tau}$, then either $e$ is a value or there exists an expression $e'$ such that $e \step e'$ and $\hastype{}{}{e'}{\tau}$. TODO the type of $e'$ is part of preservation, isn't it??

% The proof is by induction on the typing relation $\hastype{}{\Gamma}{e}{\tau}$, but the claim to be proved is augmented by \textquote{or $\Gamma$ is non-empty}.\footnote{This ensures that we can perform the induction on the entire ternary relation, which is important since this relation is the one that is defined by the inference rules, \emph{not} the corresponding binary relation obtained by restricting the ternary relation to the subset where $\Gamma = \emptyset$.} Notice that the induction step for each inference rule is trivial if $\Gamma$ is non-empty, so we need only prove the induction step when $\Gamma = \emptyset$.

% \infrule{T-unit} Since $\unitval$ is a value, this follows.

% \infrule{T-var} Since we may assume that $\Gamma$ is empty, this implication is vacuously true.

% \infrule{T-pair} Assume that $\hastype{}{}{e_1}{\tau_1}$ and $\hastype{}{}{e_2}{\tau_2}$. If both $e_1$ and $e_2$ are values, then $(e_1,e_2)$ is also a value, so assume that only $e_1 = v_1$ is a value and that $e_2 \step e_2'$ with $\hastype{}{}{e_2'}{\tau_2}$. Then by definition of the one-step relation, there must be an evaluation context $K$ and basic [TODO what to call them?] subexpressions $d_2$ and $d_2'$ of $e_2$ and $e_2'$ such that $e_2 = K[d_2]$, $e_2' = K[d_2']$ and $d_2 \headstep d_2'$. Letting $K' = (v_1,K)$ it follows that $(v_1,e_2) = K'[d_2]$ and $(v_1,e_2') = K'[d_2']$, and so
% %
% \begin{equation*}
%     (v_1,e_2)
%         = K'[d_2]
%         \step K'[d_2']
%         = (v_1,e_2').
% \end{equation*}
% %
% Finally, since $d_2$ and $d_2'$ have the same type [TODO], by [TODO ECtx typing lemma] $K'[d_2']$ is well-typed and has the same type as $K'[d_2]$.

% If instead $e_1$ is not a value, then the same argument (using the evaluation context $(K,e_2)$) yields the same result.


---------

Let $X$ be a set, and let $P$ be a predicate on $X$ (i.e., a unary relation on -- or simply a subset of -- $X$). For $x \in X$ we write $P(x)$ to mean $x \in P$. If $f \colon X^k \pto X$ is a partial function for some $k \in \naturals$, then we say that $P$ \keyword{satisfies} the inference rule $R_f$ if $P(x_1) \land \cdots \land P(x_k)$ implies $P(f(x_1,\ldots,x_k))$ for all $(x_1,\ldots,x_k) \in \dom f$. We write the inference rule on the form
%
\begin{equation*}
    \frac{P(x_1) \quad \cdots \quad P(x_k)}{P(f(x_1,\ldots,x_k))},
\end{equation*}
%
where it is implicit that $(x_1,\ldots,x_k)$ lies in $\dom f$.

As an example, in the simply typed lambda calculus $X$ is the set of triples $(\Gamma,e,\tau)$, where $\Gamma$ is a type context, $e$ an expression and $\tau$ a type. The function $f$ might be unary and have as domain the set of triples such that $\tau$ is a product type, say $\tau_1 \prod \tau_2$, and it might then map $(\Gamma,e,\tau_1 \prod \tau_2)$ to $(\Gamma, \Snd e, \tau_2)$. Of course, using the conventional notation we would write e.g. the statement $P(\Gamma,e,\tau_1 \prod \tau_2)$ as $\hastype{}{\Gamma}{\Sigma}{e}{\tau_1 \prod \tau_2}$, and $P(\Gamma, \Snd e, \tau_2)$ would be written $\hastype{}{\Gamma}{\Sigma}{\Snd e}{\tau_2}$, so the rule $R_f$ would then just be the rule $\infrule{T-snd}$.

We also wish to require a given predicate to satisfy a collection of axioms. As motivation, notice that the antecedent of the rule \infrule{T-var} is not on the same form as the consequent. That is, it is not an inductive rule, and it can thus be stated as an axiom. To wit, if $(e : \tau) \in \Gamma$ then $P(\Gamma,e,\tau)$. Another way to describe this is as the set $\set{(\Gamma,e,\tau)}{(e : \tau) \in \Gamma}$. Hence we may simply use subsets of the universal set $X$ as axioms. Of course, if $\calA$ is a collection of axioms, then $\bigunion \calA$ is also an axiom. Hence if given any number [TODO set many?] of axioms, we can always take their union and assume that there is only one axiom.

Given an axiom [TODO or set of axioms?] $A$ and a collection $\calR$ of inference rules, we first define a function $F \colon \powerset{X} \to \powerset{X}$ by
%
\begin{equation*}
    F(B)
        = \bigunion_{R \in \calR} f_R(B^{\rho(R)}),
\end{equation*}
%
where $f_R$ is some partial function inducing $R$, and $\rho(R)$ is the arity of $f_R$. For $A \subseteq X$ we further let $F_A(B) = F(B) \union A$ [TODO alternatively consider sublattice of sets $\supseteq A$]. It is clear that a set $P$ is a fixed point of $F$ if and only if $P$ is closed under application of the inference rules in $\calR$. It is furthermore easy to show that $P$ is a fixed point of $F_A$ if and only if $P$ is a fixed point of $F$ which contains $A$ [TODO need that $B \subseteq F(B)$, maybe assume that $\calR$ contains the identity/trivial rule?]. Now notice that $\powerset{X}$ is a complete lattice (with respect to set inclusion), and that $F_A$ is order-preserving. The Knaster--Tarski fixed point theorem [TODO ref] then implies that $F_A$ has a least fixed point\footnote{It also has a greatest fixed point, but this is trivially $\powerset{X}$ itself and is of no interest to us.}. We say that this fixed point is the predicate \keyword{induced} by $\calR$ and $A$.

We would also like a way to generate the predicate $P$ induced by $\calR$ and $A$. Let $A_0 = A$, and for $n \in \naturals$ define
%
\begin{equation*}
    A_{n+1}
        = F_{A_n}(A_n)
        = A_n \union \bigunion_{R \in \calR} f_R(A_n^{\rho(R)}).
\end{equation*}
%
The sequence $(A_n)_{n \in \naturals}$ is thus increasing. Letting $P = \bigunion_{n \in \naturals} A_n$, we then have the following result:

\begin{proposition}
    $P$ is the smallest predicate on $X$ which is true on all elements in $A$ and which satisfies all inference rules in $\calR$.
\end{proposition}

\begin{proof}
    Clearly $P$ is true on $A$, so consider an inference rule $R \in \calR$ and let $(x_1,\ldots,x_k) \in \dom f_R$ be such that $P(x_1), \ldots, P(x_k)$ hold, i.e. such that $x_1, \ldots, x_k \in P$. We must then show that also $f_R(x_1, \ldots, x_k) \in P$. Then there must be indices $n_1, \ldots, n_k$ such that $x_i \in A_{n_i}$. Letting $n = \max\{n_1, \ldots, n_k\}$ we thus have\footnote{This is where the proof fails if the arity of $f_R$ is infinite. For instance, the proof does not go through for $\sigma$-algebras -- where $f_R$ might map a sequence $(B_n)_{n \in \naturals}$ of sets to the union $\bigunion_{n \in \naturals} B_n$ -- nor for topologies.} $x_1, \ldots, x_k \in A_n$. Hence $f_R(x_1, \ldots, x_k) \in f_R(A_n^k)$, so by definition of $A_{n+1}$ we have $f_R(x_1, \ldots, x_k) \in A_{n+1} \subseteq P$ as desired.

    Conversely we show that $P$ is the smallest such predicate. But this is clear since it must be contained in every predicate containing $A$ and satisfying the inference rules.
\end{proof}

\begin{corollarynoproof}
    Every $x \in X$ such that $P(x)$ holds is obtained from $A$ by applying the inference rules in $\calR$ finitely many times. In particular there is an inference rules that was applied last.
\end{corollarynoproof}


We are of course used to these kinds of results in computer science, and we rarely stop to spell out the details. Since $P$ is the smallest predicate on $X$ with the above properties, we obtain a notion of structural induction or rule induction, and this is often sufficient to prove properties of $P$. But sometimes it is at least much more convenient to appeal to the \textquote{last inference rule applied}, as we shall see.\footnote{As mentioned, the proof of TODO does not go through for $\sigma$-algebras. The best we can do is apparently the following: If $\calD = \calD_0$ is a collection of subsets of $X$, let $\sigma(\calD)$ denote the smallest $\sigma$-algebra on $X$ containing $\calD$. If $\alpha$ is a countable ordinal with an immediate predecessor $\beta$, then we define $\calD_\alpha$ by transfinite induction to be the set of countable unions of elements of $\calD_\beta$ and complements of such sets, and otherwise we let $\calD_\alpha = \bigunion_{\beta < \alpha} \calD_\beta$. Then one can show that $\sigma(\calD) = \bigunion_{\alpha \in \Omega} \calD_\alpha$, where $\Omega$ is the set of countable ordinals. Cf. Folland TODO. Note however that we by minimality of $\sigma(\calD)$ do get a notion of induction, just as for predicates defined by inference rules. \par For topologies we do have a simple characterisation of the topology $\calT$ generated by a collection of sets $\calS$. In this case $\calS$ is a subbasis for $\calT$, i.e., every set in $\calT$ is a (generally infinite) union of finite intersections of elements in $\calS$. But notice that infinitely many set operations (finite intersections or arbitrary unions) are still required to obtain a general open set, since we take a finite intersection infinitely many times. \par On the other hand, results such as TODO ref are of course standard fare in algebra, where we obtain a similar description of the subalgebra generated by a subset of some algebra. See e.g. Bergman TODO}

% \newcommand{\wand}{\mathrel{-\!\!*}}
% \newcommand{\wand}{\mathrel{-\mkern-9mu-\mkern-7mu*}}
% \newcommand{\revast}{\text{\reflectbox{$*$}}}
% \newcommand{\wand}{\mathrel{-\mkern-10mu-\mkern-7mu\revast}}

% \begin{equation*}
%     \inferrule*[right=$\wand$E]{
%         \inferrule*{}{
%             P \vdash Q \wand R
%         }
%         \and
%         \inferrule*[right=Asm]{ }{
%             Q \vdash Q
%         }
%     }{
%         P * Q \vdash R
%     }
% \end{equation*}

% \begin{equation*}
%     \inferrule*[right=$\land$I]{
%         \inferrule*[right=$*$-weak]{ }{
%             P * Q \vdash P
%         }
%         \and
%         \inferrule*[right=Trans]{
%             \inferrule*[right=$*$-comm]{ }{
%                 P * Q \vdash Q * P
%             }
%             \and
%             \inferrule*[right=$*$-weak]{ }{
%                 Q * P \vdash Q
%             }
%         }{
%             P * Q \vdash Q
%         }
%     }{
%         P * Q \vdash P \land Q
%     }
% \end{equation*}

% Preservation: If $\hastype{\Xi}{\Gamma}{\Sigma}{e}{\tau}$ and $e \step e'$, then $\hastype{\Xi}{\Gamma}{\Sigma}{e'}{\tau}$.

\begin{theorem}[Preservation]
    If
    %
    \begin{equation*}
        \hastype{\Xi}{\Gamma}{\Sigma}{e}{\tau},
        \quad
        \stotype{\Xi}{\Gamma}{\Sigma}{\sigma}
        \quad \text{and} \quad
        (\sigma,e) \step (\sigma',e'),
    \end{equation*}
    %
    then there exists some store typing $\Sigma'$ with $\Sigma \subseteq \Sigma'$ such that
    %
    \begin{equation*}
        \hastype{\Xi}{\Gamma}{\Sigma'}{e'}{\tau}
        \quad \text{and} \quad
        \stotype{\Xi}{\Gamma}{\Sigma'}{\sigma'}.
    \end{equation*}
\end{theorem}

\begin{proof}
    By definition of the one-step relation, there exist an evaluation context $K$ and subexpressions $d$ of $e$ and $d'$ of $e'$ such that $e = K[d]$, $e' = K[d']$, and $(\sigma,d) \headstep (\sigma',d')$. By \cref{lem:subexp-well-typed} there is some type $\rho$ such that $\hastype{\Xi}{\Gamma}{\Sigma}{d}{\rho}$. Next it follows from \cref{lem:preservation-head-steps} that $\hastype{\Xi}{\Gamma}{\Sigma'}{d'}{\rho}$ for some store typing $\Sigma'$ with $\Sigma \subseteq \Sigma'$ and $\stotype{\Xi}{\Gamma}{\Sigma'}{\sigma'}$. By \cref{lem:store-typing-weakening} we also have $\hastype{\Xi}{\Gamma}{\Sigma'}{d}{\rho}$, so it follows from \cref{lem:evaluation-contexts-respect-types} that $\hastype{\Xi}{\Gamma}{\Sigma'}{K[d']}{\tau}$ as desired.
\end{proof}


\begin{lemma}
    \label{lem:subexp-well-typed}
    If $K$ is an evaluation context, $e$ is an expression and $\hastype{\Xi}{\Gamma}{\Sigma}{K[e]}{\tau}$, then $\hastype{\Xi}{\Gamma}{\Sigma}{e}{\rho}$ for some type $\rho$.
\end{lemma}

\begin{proof}
Every evaluation context is obtained from the hole \enquote{$\hole$} by finitely many applications of the productions in the grammar [TODO prove this?]. We prove the claim by induction on the length of such a sequence of productions. If $K = \hole$, then the claim is obvious, since then $K[e] = e$. Hence we assume that $K$ is obtained from some evaluation context $K'$ by some application of a production, so that the induction hypothesis holds for $K'$.
%
\begin{proofsec}
    \item[$K = \objPair{K'}{e'}$]
    Then $K[e] = \objPair{K'[e]}{e'}$, and since this is well-typed with type $\tau$, the inversion lemma [TODO proof] implies that $\hastype{\Xi}{\Gamma}{\Sigma}{K'[e]}{\tau_1}$ for some type $\tau_1$. By induction applied to $K'$ we have $\hastype{\Xi}{\Gamma}{\Sigma}{e}{\rho}$ for some type $\rho$.

    \item[$K = \objPair{v}{K'}$]
    Similar to the above.

    \item[$K = \objFst{K'}$]
    Then $K[e] = \objFst{K'[e]$}, so the inversion lemma implies that $\hastype{\Xi}{\Gamma}{\Sigma}{K'[e]}{\tau \prod \tau_2}$ for some $\tau_2$. By induction we have $\hastype{\Xi}{\Gamma}{\Sigma}{e}{\rho}$ for some type $\rho$.

    \item[$K \in \{\objSnd{K'}, \objInl{K'}, \objInr{K'}\}$]
    Similar to the above.

    \item[$K = \objMatch{K'}{x}{e_1}{e_2}$]
    The inversion lemma here implies that $\hastype{\Xi}{\Gamma}{\Sigma}{K'[e]}{\tau_1 + \tau_2}$, so the claim follows by induction.

    \item[$K = \objApp{K'}{e'}$]
    Then $K[e] = \objApp{K'[e]}{e'}$, so the inversion lemma implies that $\hastype{\Xi}{\Gamma}{\Sigma}{K'[e]}{\tau_1 \to \tau}$ for some type $\tau_1$. The claim follows by induction as before.

    \item[$K = \objApp{v}{K'}$]
    Similar to the above.

    \item[$K = \objTapp{K'}{X}$]
    The inversion lemma implies that $\hastype{\Xi}{\Gamma}{\Sigma}{K'[e]}{\tau_1}$ for some type $\tau_1$, so the claim follows by induction.

    \item[$K = $]
    TODO

    \item[$K = \objRef{K'}$]
    Then $K[e] = \objRef{K'[e]}$, so the inversion lemma implies that $\hastype{\Xi}{\Gamma}{\Sigma}{K'[e]}{\tau'}$. The claim follows by induction.

    \item[$K = \objAss{K'}{e'}$]
    Then $K[e] = \objAss{K'[e]}{e'}$, so the inversion lemma implies that $\hastype{\Xi}{\Gamma}{\Sigma}{K'[e]}{\tau'}$ ... TODO
\end{proofsec}

TODO rest -- but they are all the same, so maybe just do one?
\end{proof}


\begin{lemma}
    \label{lem:store-typing-weakening}
    If $\Sigma$ and $\Sigma'$ are store typings with $\Sigma \subseteq \Sigma'$ and $\hastype{\Xi}{\Gamma}{\Sigma}{e}{\tau}$, then $\hastype{\Xi}{\Gamma}{\Sigma'}{e}{\tau}$.
\end{lemma}

\begin{proof}
    TODO
\end{proof}


\begin{lemma}
    \label{lem:evaluation-contexts-respect-types}
    If $\hastype{\Xi}{\Gamma}{\Sigma}{e}{\tau}$ and $\hastype{\Xi}{\Gamma}{\Sigma}{e'}{\tau}$ for the same type $\tau$, then $\hastype{\Xi}{\Gamma}{\Sigma}{K[e]}{\rho}$ and $\hastype{\Xi}{\Gamma}{\Sigma}{K[e']}{\rho}$ for the same type $\rho$.
\end{lemma}

\begin{proof}
The proof is by induction on $K$. If $K = \hole$, then this is obvious.
%
\begin{proofsec}
    \item[$K = \objPair{K'}{e''}$]
    Then $K'[e]$ and $K'[e']$ have the same type, so by \infrule{T-pair}, so do $K[e]$ and $K[e']$.

    \item[$K = \objTapp{K'}{\tau'}$]
    Then $K'[e]$ and $K'[e']$ have the same type by induction, and so do $K[e] = \objTapp{K'[e]}{\tau'}$ and $K[e'] = \objTapp{K'[e']}{\tau'}$ by \infrule{T-Tapp}.\footnote{TODO since we just apply it to underscore, it actually has a lot of different types. But we can find one type that works for both.} [TODO need lemma saying that $\tau[\tau'/X]$ is a type! Need another production that says that $X$ is a type?]
\end{proofsec}

TODO rest
\end{proof}


\begin{lemma}
    \label{lem:preservation-head-steps}
    If $\hastype{\Xi}{\Gamma}{\Sigma}{e}{\tau}$ and $\stotype{\Xi}{\Gamma}{\Sigma}{\sigma}$ and $(\sigma,e) \headstep (\sigma',e')$, then there exists a store typing $\Sigma'$ such that $\Sigma \subseteq \Sigma'$, $\hastype{\Xi}{\Gamma}{\Sigma'}{e'}{\tau}$, and $\stotype{\Xi}{\Gamma}{\Sigma'}{\sigma'}$.
\end{lemma}

\begin{proof}
We simply check all cases. [TODO mention pure cases]
%
\begin{proofsec}
    \item[\infrule{E-fst}]
    In this case $e = \objFst{\objPair{v_1}{v_2}}$ and $e' = v_1$ for values $v_1,v_2$. Then $e$ is a value, so [TODO canonical forms] implies first that $\hastype{\Xi}{\Gamma}{\Sigma}{\objPair{v_1}{v_2}}{\tau \prod \tau'}$ for some type $\tau'$, and then that $\hastype{\Xi}{\Gamma}{\Sigma}{v_1}{\tau}$.

    \item[\infrule{E-tapp-tlam}]
    Write the type of $\objTapp{\objForall{X}{e}}{\tau'}$ as $\tau[\tau'/X]$. By inversion we have $\hastype{\Xi}{\Gamma}{\Sigma}{\objForall{X}{e}}{\typeForall{X}{\tau}}$, and again by inversion this implies that $\hastype{\Xi,X}{\Gamma}{\Sigma}{e}{\tau}$. But then it follows from [TODO lemma 0] that $\hastype{\Xi}{\Gamma[\tau'/X]}{\Sigma}{e}{\tau[\tau'/X]}$, and since $\Gamma$ does not contain $X$ (since $\Xi$ does not) we have $\Gamma[\tau'/X] = \Gamma$, so the claim follows.

    \item[\infrule{E-alloc}]
    In this case $e = \objRef{v}$, $e' = l$, $\sigma' = \sigma[l \mapsto v]$, and $l \not\in \dom \sigma$. By inversion we have $\hastype{\Xi}{\Gamma}{\Sigma}{\objRef{v}}{\typeRef{\tau'}}$ for some $\tau'$, and we further have $\hastype{\Xi}{\Gamma}{\Sigma}{v}{\tau'}$. Now letting $\Sigma' = \Sigma[l \mapsto \tau']$, it follows from \infrule{T-loc} that $\hastype{\Xi}{\Gamma}{\Sigma'}{l}{\typeRef{\Sigma'(l)}}$, so we have both $\stotype{\Xi}{\Gamma}{\Sigma'}{\sigma'}$ and $\hastype{\Xi}{\Gamma}{\Sigma'}{l}{\typeRef{\tau'}}$.

    \item[\infrule{E-store}]
    Here $e = \objAss{l}{v}$, $e' = \objUnit$ and $\sigma' = \sigma[l \mapsto v]$ with $l \in \dom \sigma$. Notice first that $\objAss{l}{v}$ and $\objUnit$ both have type $\typeUnit$ by inversion, so that $\hastype{\Xi}{\Gamma}{\Sigma}{\objUnit}{\typeUnit}$ as required.

    By inversion we also have $\hastype{\Xi}{\Gamma}{\Sigma}{l}{\typeRef{\tau'}}$ and $\hastype{\Xi}{\Gamma}{\Sigma}{v}{\tau'}$ for some type $\tau'$, and another application of inversion (TODO via \infrule{T-loc}, or canonical forms?) implies that $\tau' = \Sigma(l)$. Furthermore, since $\stotype{\Xi}{\Gamma}{\Sigma}{\sigma}$, we have $\hastype{\Xi}{\Gamma}{\Sigma}{\sigma(l)}{\Sigma(l)}$. Since $v = \sigma'(l)$ it thus follows that $\hastype{\Xi}{\Gamma}{\Sigma}{\sigma'(l)}{\Sigma(l)}$, so $\stotype{\Xi}{\Gamma}{\Sigma}{\sigma'}$.

    \item[\infrule{E-load}]
    Here $e = \objLoad{l}$, $e' = v$ and $\sigma = \sigma'$ with $\sigma(l) = v$. By inversion we have $\hastype{\Xi}{\Gamma}{\Sigma}{l}{\typeRef{\tau}}$, so $\tau = \Sigma(l)$ [TODO again]. But since $\stotype{\Xi}{\Gamma}{\Sigma}{\sigma}$ we have $\hastype{\Xi}{\Gamma}{\Sigma}{\sigma(l)}{\Sigma(l)}$, or in other words, $\hastype{\Xi}{\Gamma}{\Sigma}{v}{\tau}$.
\end{proofsec}

TODO rest
\end{proof}


--- TODO substitution lemma


\begin{lemma}
    If $\hastype{\Xi,X}{\Gamma}{\Sigma}{e}{\tau}$, then $\hastype{\Xi}{\Gamma[\tau'/X]}{\Sigma}{e}{\tau[\tau'/X]}$.
\end{lemma}

\begin{proof}
\begin{proofsec*}
    \item[\infrule{T-var}]
    Assume that $\hastype{\Xi,X}{\Gamma}{\Sigma}{x}{\tau}$. By inversion [TODO ish] we thus have $(x : \tau) \in \Gamma$, so $(x : \tau[\tau'/X]) \in \Gamma[\tau'/X]$ by definition of substitution. But then \infrule{T-var} implies that $\hastype{\Xi}{\Gamma[\tau'/X]}{\Sigma}{x}{\tau[\tau'/X]}$ (where we use that $X$ does not occur in the context or type, so it doesn't need to appear in $\Xi$).

    \item[\infrule{T-rec}]
    Assume that $\hastype{\Xi,X}{\Gamma}{\Sigma}{\objRec{f}{x}{e}}{\tau_1 \to \tau_2}$. By the inversion lemma [TODO ref -- also can't we just do induction??] we have $\hastype{\Xi,X}{\Gamma, f : \tau_1 \to \tau_2, x : \tau_1}{\Sigma}{e}{\tau_2}$, so by induction it follows that $\hastype{\Xi}{\Gamma[\tau'/X], f : \tau_1[\tau'/X] \to \tau_2[\tau'/X], x : \tau_1[\tau'/X]}{\Sigma}{e}{\tau_2[\tau'/X]}$ [TODO by substitution on envs, function types etc.]. Applying \infrule{T-rec} we obtain the desired claim.
\end{proofsec*}

TODO rest

% Antag Ξ, X | Γ ⊢ rec f(x) := e : τ₁ → τ₂ og vis Ξ | Γ[τ'/X] ⊢ rec f(x) := e : (τ₁ → τ₂)[τ'\X]
% Per inversion i antagelsen ved vi, at Ξ, X | Γ, f : τ₁ → τ₂, x : τ₁ ⊢ e : τ₂. Fra induktionshypotesen konkludrer vi så Ξ | Γ[τ'\X], f : τ₁[τ'\X] → τ₂[τ'\X], x : τ₁[τ'\X] ⊢ e : τ₂[τ'\X] idet (τ₁ → τ₂)[τ'\X] = τ₁[τ'\X] → τ₂[τ'\X] og da definitionen af substitution på miljøjer giver os, at (Γ, x : τ)[τ'\X] = Γ[τ'\X], x : τ[τ'\X]. Dernæst følger udsagnet, som vi vil vise direkte af T-rec.

% De interessante tilfælde er (surprise, surprise) derimod for T-Tlam og T-Ttapp.

% T-Tlam 
% Antag Ξ, X | Γ ⊢ Λ e : ∀ Y . τ og vis at Ξ | Γ[τ'\X] ⊢ Λ e : (∀ Y . τ)[τ'/X]
% Vær spids på, at jeg her udnytter, at vi ræsonnerer modulo "alpha-ækvivalens", dvs. at vi kan omnavngive (type)variable frit. Det gør jeg ved at gøre brug en frisk variabel Y og ræsonere med en implicit antagelse om at X ≠ Y.
% Per inversion i antagelsen får vi, at Ξ, X, Y | Γ ⊢ e : τ. Husk, at typemiljøer er mængder, dvs Ξ, X, Y = Ξ, Y, X, og dermed gælder (Ξ, Y), X | Γ ⊢ e : τ også. Brug nu induktionshypotesen med (Ξ, Y) som miljø, og vi får Ξ, Y | Γ[τ'\X] ⊢ e : τ[τ'\X]. Vi kan nu konkludere vha. T-Tlam og da (∀ Y . τ)[τ'/X] = ∀ Y . τ[τ'\X].

% T-Ttapp
% Antag Ξ, X | Γ ⊢ e _ : τ[τ''\Y] og vis at Ξ | Γ[τ'\X] ⊢ e _ : τ[τ''\Y][τ'\X]. Igen, vær opmærksom på, at jeg er meget påpasselig med variabelnavnene!
% Per inversion i antagelsen får vi, at Ξ, X | Γ ⊢ e : ∀ Y . τ. Fra induktionhypotesen følger at Ξ | Γ[τ'\X] ⊢ e : (∀ Y . τ)[τ'\X]. Vi bruger nu igen, at (∀ Y . τ)[τ'/X] = ∀ Y . τ[τ'\X] og konkludrerer, at Ξ | Γ[τ'\X] ⊢ e : ∀ Y . τ[τ'\X]. Fra T-Tapp følger nu, at Ξ | Γ[τ'\X] ⊢ e _ : τ[τ'\X][τ''\Y]. Vi er færdige antaget τ[τ'\X][τ''\Y] = τ[τ'\Y][τ''\X], hvilket er tilfældet da X ≠ Y.

% Som I kan se er det altså forholdvist ligetil at vise, givet et par egenskaber omkring substitution, som afhænger lidt af, hvordan vi helt præcist formaliserer denne (som diskuteret i TAPL). Men det er helt fint at ræsonnere, som jeg gør ovenfor.

% For at opresumere er planen for næste gang dermed:
% - Færdiggør preservation for System F (vha typesubstitutionslemmaet ovenfor)
% - Vis progress + preservation for System F + rekursive typer (dette burde være rimeligt ligetil vha. ovenstående)
% - Kig på referencer og kom så langt I kan med progress + preservation for denne udvidelse.
\end{proof}



-------------------


\chapter{Statics in general}

\section{Syntax}

We describe the general framework in which we may describe various programming languages, introducing the concepts that will later be defined precisely in the concrete setting of System~F.

We first fix countable sets $\setVar$ of variables and $\setLoc$ of locations. The \keyword{expressions} of the language will be a set $\setExp$ containing both $\setVar$ and $\setLoc$, and we designate some of these expressions to be \keyword{values}, collected in a set $\setVal$. We think of an expression as specifying (part of) the state of the program, and values are states in which the computation of the program has finished. All locations will also be values, and these are supposed to model memory addresses. The memory state of the program (i.e. the part of the memory that the program has access to) is modelled by a \keyword{store}\footnote{Sometimes called a \keyword{heap}, but this has nothing to do with the heap \emph{data structure}.}, which is an element of $\pmaps[\omega]{\setLoc}{\setExp}$. We simply write $\setSto$ for this set of maps.

For $e \in \setExp$ we define the set $\freevar{e} \subseteq \setVar$ of \keyword{free variables}. There are various ways of binding variables in expressions, and the notion of free variables is supposed to capture the idea that variables can be bound, e.g. by lambda abstraction, and hence also \emph{not} bound. If $\freevar{e} = \emptyset$, then we say that $e$ is \keyword{closed}.


\section{Type system}

We next define a set $\setType$ of types. This includes a countable set $\setTVar$ of type variables, any base types (e.g. unit, integer, and boolean types) as well as more complex types that can be constructed recursively from the base types. It also includes reference types, which are the types of locations. For $\tau \in \setType$ we define the set of \keyword{free type variables} $\freeTvar{\tau} \subseteq \setTVar$. As with free variables, these can be bound in various ways. If $\freeTvar{\tau} = \emptyset$, then we also say that $\tau$ is \keyword{closed}. A pair $(e,\tau)$ of an expression and a type is usually written $e : \tau$. An expression may also have types as subexpressions, for instance if a lambda abstraction has a type annotation on its parameter.

If an expression $e$ has free variables, then to specify the type of $e$ it is necessary to first specify the types of the free variables in $e$. This is done using a \keyword{type context}, which is an element of $\pmaps[\omega]{\setVar}{\setType}$. If $e$ is supposed to be well-typed in a type context $\Gamma$, then we of course require that $\freevar{e} \subseteq \dom \Gamma$. That is, $\Gamma$ must in fact specify the types of the variables that occur free in $e$.

Furthermore, if $e$ has a location as a subexpression, then we need to be able to look up the type of the expression stored at this location in order to specify the type of $e$. Hence the type of $e$ will also depend on the store in question. However, it not in general possible to deduce the type of $e$ in this case: If $\sigma$ is a store, $l_1,l_2 \in \dom \sigma$, and if $\sigma(l_1)$ references $l_2$ and $\sigma(l_2)$ references $l_1$, then it is impossible to deduce the type of $\sigma(l_1)$. Hence the type of $e$ will instead depend on a given \keyword{store typing}, which is an element of $\pmaps[\omega]{\setLoc}{\setType}$. We of course require that the store typing in question actually contains in its domain all locations referenced in $e$, and we furthermore require that all free variables of $e$ lie in the domain of the current type context.

It may be that the type of $e$ or of the types of the variables in the type context $\Gamma$ or of the expressions in the store typing $\Sigma$ contain type variables. In order to keep track of these we collect these in a (finite) set $\Xi$ and require that the free type variables in $\Gamma$ and $\Sigma$, defined by
%
\begin{equation*}
    \freeTvar{\Gamma}
        = \bigunion_{\tau \in \ran \Gamma} \freeTvar{\tau}
    \quad \text{and} \quad
    \freeTvar{\Sigma}
        = \bigunion_{\tau \in \ran \Sigma} \freeTvar{\tau},
\end{equation*}
%
are contained in $\Xi$. A variable $x$ is called \keyword{fresh} for $\Gamma$ if $x \not\in \dom \Gamma$. The finitude of $\dom \Gamma$ ensures that there always exist fresh variables (recall that there are countably infinitely many variables). If $\Delta$ is another type context such that $\dom \Gamma \intersect \dom \Delta = \emptyset$, then instead of $\Gamma \union \Delta$ we simply write $\Gamma,\Delta$. Furthermore, if $\Delta = \{x_1 : \tau_1, \ldots, x_n : \tau_n\}$ for distinct $x_i$, then we omit the braces and write $\Gamma, x_1 : \tau_1, \ldots, x_n : \tau_n$. If $\Xi$ and $\Phi$ are finite disjoint subsets of $\setTVar$, then we similarly write $\Xi,\Phi$ for $\Xi \union \Phi$, and if $\Phi = \{X_1, \ldots, X_n\}$ for distinct $X_i$, then we also write $\Xi, X_1, \ldots, X_n$.

The semantics of the type system is captured by a five-place relation on the set
%
\begin{equation*}
    \powersetfin{\setTVar}
        \prod (\pmaps[\omega]{\setVar}{\setType})
        \prod (\pmaps[\omega]{\setLoc}{\setType})
        \prod \setExp
        \prod \setType,
\end{equation*}
%
where an element $(\Xi,\Gamma,\Sigma,e,\tau)$ of this relation is written $\hastype{\Xi}{\Gamma}{\Sigma}{e}{\tau}$ and is called a \keyword{type derivation}. This relation is usually defined recursively, by specifying a series of axioms and inference rules\footnote{Or more usually axiom and rule \emph{schemas}. TODO Pierce}. If $\Xi = \emptyset$, then we write $\hastype{}{\Gamma}{\Sigma}{e}{\tau}$ [TODO do we need this?], and we furthermore write $\hastype{}{}{\Sigma}{e}{\tau}$ if also $\Gamma = \emptyset$.


\chapter{Dynamics in general}

The operational semantics of the language is specified in a small-step style. We describe this semantics in stages, beginning with the \keyword{pure head reductions}. These are evaluations that can be performed (1) on expressions that have no subexpressions that can be evaluated, (2) without reading or modifying the store. More precisely, we specify a binary relation $\purestep$ on $\setExp$, such that $e \purestep e'$ is supposed to mean that $e$ evaluates to or reduces to $e'$.

Going one level up we define the relation $\headstep$ on $\setSto \prod \setExp$ of (not necessarily pure) \keyword{head reductions}. These are reductions that may affect and be affected by the contents of the store. Of course, if $\sigma$ is a store and $e \purestep e'$, then we have $(\sigma,e) \headstep (\sigma,e')$, but we augment the pure head reductions with reductions that e.g. read from or write to the store.

Finally we need a way to evaluate complex expressions. One way of doing this is to specify the evaluation rules for all expressions immediately instead of going through head reductions (this is the approach taken by Pierce TODO). Another is to introduce \keyword{evaluation contexts}, which are (essentially) maps $\setExp \to \setExp$. If $K$ is an evaluation context and $e$ is an expression, then we write $K[e]$ for the value of $K$ at $e$. We then define the final reduction relation $\step$ on $\setSto \prod \setExp$ by letting $(\sigma, K[e]) \step (\sigma', K[e'])$ if $(\sigma,e) \headstep (\sigma',e')$.

One role of evaluation contexts is to specify the evaluation order of complex expressions, e.g. if the evaluation of function applications is call-by-value or call-by-name, or if we evaluate the arguments to functions left-to-right or right-to-left. The possibilities thus depend on the available evaluation contexts.

TODO multiple threads


\chapter{System F}

The following grammar defines the syntax, the sets of values and types, and the evaluation contexts of System F:
%
\begin{alignat*}{2}
    && x &\in \setVar \\
    && l &\in \setLoc \\
    && X &\in \setTVar \\
    & \setExp \quad & e &\Coloneqq \objUnit \mid x \mid l \mid \objPair{e}{e} \mid \cdots \\
    & \setVal \quad & v &\Coloneqq \objUnit \mid l \mid \objPair{v}{v} \mid \objInl{v} \mid \cdots \\
    & \setType \quad & \tau &\Coloneqq \typeUnit \mid X \mid \typeRef{\tau} \mid \tau \prod \tau \mid \cdots \\
    & \setECtx \quad & K &\Coloneqq \hole \mid \objPair{K}{e} \mid \objPair{v}{K} \mid \cdots
\end{alignat*}
%
Notice that $\setLoc \subseteq \setVal \subseteq \setExp$ as we required in TODO ref. If $K$ is an evaluation context and $e$ is an expression, then we define $K[e]$ recursively by
%
\begin{align*}
    \hole[e] &= e \\
    \objPair{K}{e'}[e] &= \objPair{K[e]}{e'} \\
    \objPair{v}{K}[e] &= \objPair{v}{K[e]} \\
    & etc.
\end{align*}
%
The symbol \enquote{$\hole$} is called the \keyword{hole}, and we think of the hole as the place into which we substitute the expression $e$. It is easy to prove (by induction in $K$) that $K[e]$ is an expression, so every evaluation context $K$ can indeed be thought of as a map $\setExp \to \setExp$ given by $e \mapsto K[e]$.

If $e$ is an expression, then the set $\freevar{e}$ of free variables in $e$ is defined recursively as follows:
%
\begin{align*}
    \freevar{\objUnit} &= \emptyset \\
    \freevar{x} &= \{x\} \\
    \freevar{\objPair{e_1}{e_2}} &= \freevar{e_1} \union \freevar{e_2} \\
    & etc.
\end{align*}
%
Similarly, if $\tau$ is a type, then we define the set $\freeTvar{\tau}$ of free type variables in $\tau$ as follows:
%
\begin{align*}
    \freeTvar{\typeUnit} &= \emptyset \\
    \freeTvar{X} &= \{X\} \\
    \freeTvar{\tau_1 \prod \tau_2} &= \freeTvar{\tau_1} \union \freeTvar{\tau_2} \\
    & etc.
\end{align*}

We are now in a position to define the typing relation. This is the smallest relation on the set
%
\begin{equation*}
    \powersetfin{\setTVar}
        \prod (\pmaps[\omega]{\setVar}{\setType})
        \prod (\pmaps[\omega]{\setLoc}{\setType})
        \prod \setExp
        \prod \setType,
\end{equation*}
%
satisfying the following inference rules:

\begin{equation*}
    \inferrule*[right=T-var]{
        \freeTvar{\Gamma} \subseteq \Xi
        \and
        \freeTvar{\Sigma} \subseteq \Xi
        \and
        (x : \tau) \in \Gamma
    }{
        \hastype{\Xi}{\Gamma}{\Sigma}{x}{\tau}
    }
\end{equation*}

Lemma: If $\hastype{\Xi}{\Gamma}{\Sigma}{e}{\tau}$, then $\freeTvar{\Gamma} \subseteq \Xi$ and $\freevar{e} \subseteq \dom \Gamma$. In particular, if $\Xi = \emptyset$ then $\tau$ is closed, and if $\Gamma = \emptyset$ then $e$ is closed. TODO

TODO all type variables in tau also in Xi? All locations in e also in Sigma?

TODO lemma weakening?





\end{document}